"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GeneratePage = void 0;
const discord_js_1 = require("discord.js");
const types_js_1 = require("../types.js");
const paginate_js_1 = require("./paginate.js");
function GeneratePage(item, page, totalPages, option) {
    const beginning = page === 0;
    const end = page === totalPages - 1;
    const newMessage = typeof item === "string"
        ? { content: item }
        : item instanceof discord_js_1.MessageEmbed
            ? { embeds: [item] }
            : item;
    function isStartEndAllowed() {
        if (option.showStartEnd === undefined) {
            return true;
        }
        if (typeof option.showStartEnd === "number") {
            return totalPages >= option.showStartEnd;
        }
        return option.showStartEnd;
    }
    if (option.type === types_js_1.PaginationType.Button) {
        const startBtn = new discord_js_1.MessageButton()
            .setCustomId(option.start?.id ?? types_js_1.defaultIds.buttons.start)
            .setLabel(option.start?.label ?? "Start")
            .setStyle(option.start?.style ?? "PRIMARY")
            .setDisabled(beginning);
        const endBtn = new discord_js_1.MessageButton()
            .setCustomId(option.end?.id ?? types_js_1.defaultIds.buttons.end)
            .setLabel(option.end?.label ?? "End")
            .setStyle(option.end?.style ?? "PRIMARY")
            .setDisabled(end);
        const nextBtn = new discord_js_1.MessageButton()
            .setCustomId(option.next?.id ?? types_js_1.defaultIds.buttons.next)
            .setLabel(option.next?.label ?? "Next")
            .setStyle(option.next?.style ?? "PRIMARY")
            .setDisabled(end);
        const prevBtn = new discord_js_1.MessageButton()
            .setCustomId(option.previous?.id ?? types_js_1.defaultIds.buttons.previous)
            .setLabel(option.previous?.label ?? "Previous")
            .setStyle(option.previous?.style ?? "PRIMARY")
            .setDisabled(beginning);
        const exitBtn = new discord_js_1.MessageButton()
            .setCustomId(option.exit?.id ?? types_js_1.defaultIds.buttons.exit)
            .setLabel(option.exit?.label ?? "Exit")
            .setStyle(option.exit?.style ?? "DANGER");
        // set emoji
        if (option.start?.emoji) {
            startBtn.setEmoji(option.start.emoji);
        }
        if (option.end?.emoji) {
            endBtn.setEmoji(option.end.emoji);
        }
        if (option.next?.emoji) {
            nextBtn.setEmoji(option.next.emoji);
        }
        if (option.previous?.emoji) {
            prevBtn.setEmoji(option.previous.emoji);
        }
        if (option.exit?.emoji) {
            exitBtn.setEmoji(option.exit.emoji);
        }
        const buttons = [prevBtn, nextBtn];
        if (isStartEndAllowed()) {
            buttons.unshift(startBtn);
            buttons.push(endBtn);
        }
        if (option.enableExit) {
            buttons.push(exitBtn);
        }
        const row = new discord_js_1.MessageActionRow().addComponents(buttons);
        // reset message payload additional parameters
        if (!newMessage.embeds) {
            newMessage.embeds = [];
        }
        if (!newMessage.files) {
            newMessage.files = [];
        }
        if (!newMessage.files) {
            newMessage.files = [];
        }
        if (!newMessage.attachments) {
            newMessage.attachments = [];
        }
        return { newMessage, paginationRow: row };
    }
    else {
        const paginator = (0, paginate_js_1.paginate)(totalPages, page, 1, 21).pages.map((i) => {
            // get custom page title
            const text = option.pageText instanceof Array
                ? option.pageText[i - 1]
                : option.pageText;
            return {
                label: (text ?? "Page {page}").replaceAll("{page}", `${i}`),
                value: (i - 1).toString(),
            };
        });
        if (isStartEndAllowed()) {
            // add start option
            paginator.unshift({
                label: option.labels?.start ?? "Start",
                value: types_js_1.SelectMenuPageId.Start.toString(),
            });
            // add end option
            paginator.push({
                label: option.labels?.end ?? "End",
                value: types_js_1.SelectMenuPageId.End.toString(),
            });
        }
        // add exit option
        if (option.enableExit) {
            paginator.push({
                label: option.labels?.exit ?? "Exit Pagination",
                value: types_js_1.SelectMenuPageId.Exit.toString(),
            });
        }
        const menu = new discord_js_1.MessageSelectMenu()
            .setCustomId(option.menuId ?? types_js_1.defaultIds.menu)
            .setPlaceholder(option.placeholder ?? "Select page")
            .setOptions(paginator);
        const row = new discord_js_1.MessageActionRow().addComponents([menu]);
        // reset message payload additional parameters
        if (!newMessage.embeds) {
            newMessage.embeds = [];
        }
        if (!newMessage.files) {
            newMessage.files = [];
        }
        if (!newMessage.files) {
            newMessage.files = [];
        }
        if (!newMessage.attachments) {
            newMessage.attachments = [];
        }
        return { newMessage, paginationRow: row };
    }
}
exports.GeneratePage = GeneratePage;
//# sourceMappingURL=GeneratePage.js.map